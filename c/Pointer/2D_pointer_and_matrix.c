
###################################################################################################

char *a[10] : 一個 char 指標陣列包含 10 個元素，元素都是 char 指標

所以 a[0] ~ a[9] 其實記憶體位置是順序的 
+------+------+------+------+------+------+------+------+------+------+------+
| a[0] | a[1] | a[2] | a[3] | a[4] | a[5] | a[6] | a[7] | a[8] | a[9] | ...  |
+------+------+------+------+------+------+------+------+------+------+------+
  |      |      |      |      |      |      |      |      |      |      |
  v      v      v      v      v      v      v      v      v      v      v
+------+------+------+------+------+------+------+------+------+------+------+
|  *   |  *   |  *   |  *   |  *   |  *   |  *   |  *   |  *   |  *   | ...  |
+------+------+------+------+------+------+------+------+------+------+------+

如果有以下函數，然後分別有 A 和 matrix 想要丟進函數裡面
void pointerToCharArray(char* str[]); // char* str[] 可以是 n*m，第一維不一定要是 1

char** A = (char**)calloc(2, sizeof(char*));
  	for(int i = 0; i < 2; i++) {
  		A[i] = (char*)calloc(5, sizeof(char));
  		sprintf(A[i], "%d, %d", i, i+1);
  	}

char matrix[2][20] = {
  		"{1, 2}",
  		"{2, 3}"
  	};


1. 第一種呼叫 pointerToCharArray(A)
char** 类型可以被隐式转换为 char*[] 类型，所以这是合法的。

2.第二種呼叫，pointerToCharArray(matrix) 會報錯，matrix[][] 並不能隱式轉換成 char* str[] 
matrix 的类型是 char[2][20]，并不能直接转换为 char*[] 类型

如果要使用 matrix 
char* arr[] = {matrix[0], matrix[1]};
pointerToCharArray(arr);
這樣才能成功

!!!!!!!!!!!!!!看一下記憶體排列!!!!!!!!!!!!!!
printf("%d\n", sizeof(char*));
printf("&A[0]: %p\n", A[0]);
printf("A[0]: %p\n", A[0]);
printf("&A[0][0]: %p\n", &A[0][0]); 
printf("&A[0][1]: %p\n", &A[0][1]);
printf("&A[1]: %p\n", A[1]); 
4
&A[0]: 009413F8
A[0]: 009413F8
&A[0][0]: 009413F8
&A[0][1]: 009413F9
&A[1]: 00941408

可以看見，其實 A[0] 地址和 A[1]地址並不是差 6 Bytes，表示兩個陣列並沒有排列在一起
但 A[0] 和 A[0][1] 有排列在一起，就跟上面畫的一樣，也因為這樣，所以二維 CHAR 指標陣列，並不能跟二維 CHAR 陣列互相轉換 

printf("strlen:%d\n", strlen(matrix[0])); //會印出 6
printf("matrix[0]: %p\n", &matrix[0]); 
printf("matrix[0][1]: %p\n", &matrix[0][1]); 
printf("matrix[1]: %p\n", &matrix[1]); // 和 matrix[0] 差 10 個 Bytes = 10 char 大小 
strlen:6
matrix[0]: 0061FEED
matrix[0][1]: 0061FEEE //放在 stack 記憶體位置由小到大，表示我的編譯器行為就是 stack 由小到大，方向都會一致，跟編譯器有關
matrix[1]: 0061FEF7 //0xF7-0xED = 10

matrix 就是一整塊




###################################################################################################

char (*a)[10] : 一個指標，指向一個 char 陣列，包含十個 char 元素
+------+
|   a  |
+------+
  |
  v
+------+------+------+------+------+------+------+------+------+------+------+
| a[0] | a[1] | a[2] | a[3] | a[4] | a[5] | a[6] | a[7] | a[8] | a[9] | ...  |
+------+------+------+------+------+------+------+------+------+------+------+

###################################################################################################

